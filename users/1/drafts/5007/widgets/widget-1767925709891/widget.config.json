{
  "id": "widget-1767925709891",
  "type": "Chart",
  "title": "Two Universes Colliding (3D)",
  "layout": {
    "x": 18,
    "y": 3,
    "w": 12,
    "h": 8,
    "minW": 2,
    "minH": 1,
    "zIndex": 0
  },
  "templateId": "1319",
  "dataSource": {
    "type": "mock",
    "config": {
      "dataType": "timeseries",
      "pointCount": 50,
      "valueRange": {
        "min": 0,
        "max": 100
      }
    },
    "refreshMode": "interval",
    "refreshIntervalMs": 5000
  },
  "configFileName": "three-scene.json",
  "dataFileName": "three-data.json",
  "codeFileName": "scene-logic.js",
  "code": "/**\n * Galaxy Spiral Chart - Theme Aware\n * Uses \u0027themeData\u0027 and \u0027theme\u0027 injected by CodeChartRenderer\n */\nconst themeThree = themeData?.threejs || {};\nconst bgValue = themeThree.backgroundColor || \u0027#050505\u0027;\n\nconst scene = new THREE.Scene();\nconst camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 2000);\nconst renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });\n\nrenderer.setSize(width, height);\nrenderer.setPixelRatio(window.devicePixelRatio);\n\n// Handle Theme Background (Dark / Light / Transparent)\nif (bgValue === \u0027transparent\u0027 || theme === \u0027transparent\u0027) {\n  renderer.setClearColor(0x000000, 0); // Fully transparent\n  scene.background = null;\n} else {\n  const bgColor = new THREE.Color(bgValue);\n  scene.background = bgColor;\n  renderer.setClearColor(bgColor, 1);\n}\n\ncontainer.appendChild(renderer.domElement);\n\n// --- Galaxy Parameters (Aligned with Plotly Theme Colors) ---\nconst parameters = {\n  count: 30000,\n  size: 3,\n  radius: 400,\n  branches: 3,\n  spin: 1,\n  randomness: 0.2,\n  randomnessPower: 3,\n  // Using Plotly standard colorway colors\n  insideColor: new THREE.Color(0xEF553B), // Plotly Red-ish\n  outsideColor: new THREE.Color(0x636efa) // Plotly Blue\n};\n\nconst geometry = new THREE.BufferGeometry();\nconst positions = new Float32Array(parameters.count * 3);\nconst colors = new Float32Array(parameters.count * 3);\n\nfor (let i = 0; i \u003C parameters.count; i\u002B\u002B) {\n  const i3 = i * 3;\n  const r = Math.random() * parameters.radius;\n  const spinAngle = (r / parameters.radius) * parameters.spin * Math.PI * 2;\n  const branchAngle = ((i % parameters.branches) / parameters.branches) * Math.PI * 2;\n\n  const randomX = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() \u003C 0.5 ? 1 : -1) * parameters.randomness * r;\n  const randomY = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() \u003C 0.5 ? 1 : -1) * (parameters.randomness * r * 0.5);\n  const randomZ = Math.pow(Math.random(), parameters.randomnessPower) * (Math.random() \u003C 0.5 ? 1 : -1) * parameters.randomness * r;\n\n  positions[i3] = Math.cos(branchAngle \u002B spinAngle) * r \u002B randomX;\n  positions[i3 \u002B 1] = randomY;\n  positions[i3 \u002B 2] = Math.sin(branchAngle \u002B spinAngle) * r \u002B randomZ;\n\n  const mixedColor = parameters.insideColor.clone();\n  mixedColor.lerp(parameters.outsideColor, r / parameters.radius);\n\n  colors[i3] = mixedColor.r;\n  colors[i3 \u002B 1] = mixedColor.g;\n  colors[i3 \u002B 2] = mixedColor.b;\n}\n\ngeometry.setAttribute(\u0027position\u0027, new THREE.BufferAttribute(positions, 3));\ngeometry.setAttribute(\u0027color\u0027, new THREE.BufferAttribute(colors, 3));\n\nconst canvas = document.createElement(\u0027canvas\u0027);\ncanvas.width = 32;\ncanvas.height = 32;\nconst ctx = canvas.getContext(\u00272d\u0027);\nconst gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);\ngradient.addColorStop(0, \u0027rgba(255, 255, 255, 1)\u0027);\ngradient.addColorStop(0.2, \u0027rgba(255, 255, 255, 0.8)\u0027);\ngradient.addColorStop(0.5, \u0027rgba(255, 255, 255, 0.1)\u0027);\ngradient.addColorStop(1, \u0027rgba(0, 0, 0, 0)\u0027);\nctx.fillStyle = gradient;\nctx.fillRect(0, 0, 32, 32);\nconst texture = new THREE.CanvasTexture(canvas);\n\nconst material = new THREE.PointsMaterial({\n  size: parameters.size,\n  sizeAttenuation: true,\n  depthWrite: false,\n  blending: THREE.AdditiveBlending,\n  vertexColors: true,\n  map: texture,\n  transparent: true\n});\n\nconst particles = new THREE.Points(geometry, material);\nscene.add(particles);\n\ncamera.position.set(0, 300, 500);\ncamera.lookAt(0, 0, 0);\n\nconst controls = new OrbitControls(camera, renderer.domElement);\ncontrols.enableDamping = true;\ncontrols.dampingFactor = 0.05;\ncontrols.autoRotate = true;\ncontrols.autoRotateSpeed = 0.5;\n\nlet animationId;\nconst animate = () =\u003E {\n  animationId = requestAnimationFrame(animate);\n  particles.rotation.y \u002B= 0.0005;\n  controls.update();\n  renderer.render(scene, camera);\n};\nanimate();\n\nreturn () =\u003E {\n  cancelAnimationFrame(animationId);\n  controls.dispose();\n  geometry.dispose();\n  material.dispose();\n  texture.dispose();\n  renderer.dispose();\n  if (container.contains(renderer.domElement)) {\n    container.removeChild(renderer.domElement);\n  }\n};",
  "isCodeDriven": false,
  "libraryCode": "threejs"
}